package zhk.love.lt.algorithm;

/**
 * 排序相关的算法
 *
 * @author zhklt521
 * @version 1.0
 * @since 1.7
 */
public interface SortService {

    /**
     * 冒泡排序（ 时间复杂度O(n2) 稳定:通俗地讲就是能保证排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同）
     * 原理：相邻元素两两比较，大的往后放（以从小到大排序为例）。
     * 第一次完毕后，最大值就出现在了最大索引处。
     * 也就是说，冒泡排序每经过一次，至少有一个元素处于最终位置。
     * 同理，继续循环，即可得到一个排序好的数组。冒泡排序次数是数组长度-1次。
     *
     * @param array
     *         需要排序的数组
     */
    void arrayBubble(int[] array);

    /**
     * 快速排序（时间复杂度O (nlogn) 不稳定）
     * 原理：通过一趟排序将要排序的数据分成独立的两部分，其中一部分的所有数据（左边的数据）都比
     * 另外一部分的所有数据（右边的数据）都要小，然后再按此方法对这两部分数据分别进行快速排序， 整个排序过程可以递归进行，以此达到整个数据变成有序的序列。
     * <p>
     * 一趟快速排序： 在要排序的数据中，首先任意选取一个数据（通常选用第一个数）作为关键数（或称为基准数），
     * 然后将所有比它小的数都放在前面（左边），所有比它大的数都放到后面（右边），这个过程称为一趟排序。
     * <p>
     * 一趟快速排序规则: 1）设置两个变量i、j，排序开始的时候：i=0，j=N-1； 2）以第一个数组元素作为关键数据(即基准数)，赋值给key，即
     * key=A[0]； 3）从j开始向前搜索，即由后开始向前搜索（j--），找到第一个小于key的值A[j]，A[i]与A[j]交换；
     * 4）从i开始向后搜索，即由前开始向后搜索（i++），找到第一个大于key的A[i]，A[i]与A[j]交换； 5）重复执行第3、4步，直到 i=j；
     * 6）到此找到基准点的下标，作为分治下标； 7）重复1-6步骤递归排序前半部分； 8）重复1-6步骤递归排序后半部分。
     *
     * @param array
     *         需要排序的数组
     */
    void quickSort(int[] array);
}
